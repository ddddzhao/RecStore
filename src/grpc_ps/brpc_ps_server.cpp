#include "brpc_ps_server.h"

#include <brpc/server.h>
#include <fmt/core.h>
#include <gflags/gflags.h>

#include <chrono>
#include <cstdint>
#include <fstream>
#include <memory>
#include <string>
#include <thread>
#include <vector>

#include "base/array.h"
#include "base/base.h"
#include "base/factory.h"
#include "base/flatc.h"
#include "base/log.h"
#include "base/timer.h"
#include "base_ps/base_ps_server.h"
#include "base_ps/cache_ps_impl.h"
#include "base_ps/parameters.h"
#include "ps_brpc.pb.h"
#include "recstore_config.h"
#include "report_client.h"

using recstoreps_brpc::CommandRequest;
using recstoreps_brpc::CommandResponse;
using recstoreps_brpc::GetParameterRequest;
using recstoreps_brpc::GetParameterResponse;
using recstoreps_brpc::InitEmbeddingTableRequest;
using recstoreps_brpc::InitEmbeddingTableResponse;
using recstoreps_brpc::PSCommand;
using recstoreps_brpc::PutParameterRequest;
using recstoreps_brpc::PutParameterResponse;
using recstoreps_brpc::UpdateParameterRequest;
using recstoreps_brpc::UpdateParameterResponse;

DEFINE_string(brpc_config_path,
              RECSTORE_PATH "/recstore_config.json",
              "config file path");
DEFINE_int32(brpc_server_port, 15000, "bRPC server port");
DEFINE_int32(brpc_server_num_threads,
             0,
             "Number of threads for bRPC server, 0 means auto");

namespace recstore {

BRPCParameterServiceImpl::BRPCParameterServiceImpl(CachePS* cache_ps)
    : cache_ps_(cache_ps) {
  start_time_ = std::chrono::steady_clock::now();
}

void BRPCParameterServiceImpl::ResetMetrics() {
  total_get_requests_ = 0;
  total_put_requests_ = 0;
  total_get_keys_     = 0;
  total_put_keys_     = 0;
  total_get_bytes_    = 0;
  total_put_bytes_    = 0;
  start_time_         = std::chrono::steady_clock::now();
}

void BRPCParameterServiceImpl::PrintMetrics(const std::string& table_name,
                                            const std::string& unique_id) {
  auto now         = std::chrono::steady_clock::now();
  double elapsed_s = std::chrono::duration<double>(now - start_time_).count();
  if (elapsed_s > 0) {
    double overall_qps =
        (total_get_requests_ + total_put_requests_) / elapsed_s;
    double overall_throughput_mbps =
        ((total_get_bytes_ + total_put_bytes_) / 1024.0 / 1024.0) / elapsed_s;

    // Report QPS and throughput metrics
    report(table_name.c_str(), unique_id.c_str(), "overall_qps", overall_qps);
    report(table_name.c_str(),
           unique_id.c_str(),
           "overall_throughput_mbps",
           overall_throughput_mbps);
  }
}

void BRPCParameterServiceImpl::GetParameter(
    google::protobuf::RpcController* controller,
    const GetParameterRequest* request,
    GetParameterResponse* response,
    google::protobuf::Closure* done) {
  brpc::ClosureGuard done_guard(done);

  base::ConstArray<uint64_t> keys_array(request->keys());
  bool isPerf = request->has_perf() && request->perf();

  if (isPerf) {
    xmh::PerfCounter::Record("PS Get Keys", keys_array.Size());
  }

  xmh::Timer timer_ps_get_req("PS GetParameter Req");
  ParameterCompressor compressor;
  std::vector<std::string> blocks;

  FB_LOG_EVERY_MS(INFO, 1000)
      << "[bRPC PS] Getting " << keys_array.Size() << " keys";

  int total_dim = 0;
  for (auto each : keys_array) {
    ParameterPack parameter_pack;
    cache_ps_->GetParameterRun2Completion(each, parameter_pack, 0);
    compressor.AddItem(parameter_pack, &blocks);
    total_dim += parameter_pack.dim;
  }

  compressor.ToBlock(&blocks);
  CHECK_EQ(blocks.size(), 1);
  response->mutable_parameter_value()->swap(blocks[0]);

  total_get_requests_++;
  total_get_keys_ += keys_array.Size();
  total_get_bytes_ += total_dim * sizeof(float);

  if (isPerf) {
    timer_ps_get_req.end();
  } else {
    timer_ps_get_req.destroy();
  }
}

void BRPCParameterServiceImpl::Command(
    google::protobuf::RpcController* controller,
    const CommandRequest* request,
    CommandResponse* response,
    google::protobuf::Closure* done) {
  brpc::ClosureGuard done_guard(done);

  if (request->command() == PSCommand::CLEAR_PS) {
    LOG(WARNING) << "[PS Command] Clear All";
    cache_ps_->Clear();
  } else if (request->command() == PSCommand::RELOAD_PS) {
    LOG(WARNING) << "[PS Command] Reload PS";
    CHECK_NE(request->arg1().size(), 0);
    CHECK_NE(request->arg2().size(), 0);
    CHECK_EQ(request->arg1().size(), 1);
    LOG(WARNING) << "model_config_path = " << request->arg1()[0];
    for (int i = 0; i < request->arg2().size(); i++) {
      LOG(WARNING) << fmt::format("emb_file {}: {}", i, request->arg2()[i]);
    }
    std::vector<std::string> arg1;
    for (auto& each : request->arg1()) {
      arg1.push_back(each);
    }
    std::vector<std::string> arg2;
    for (auto& each : request->arg2()) {
      arg2.push_back(each);
    }
    cache_ps_->Initialize(arg1, arg2);
  } else {
    LOG(FATAL) << "invalid command";
  }
}

void BRPCParameterServiceImpl::PutParameter(
    google::protobuf::RpcController* controller,
    const PutParameterRequest* request,
    PutParameterResponse* response,
    google::protobuf::Closure* done) {
  brpc::ClosureGuard done_guard(done);

  const ParameterCompressReader* reader =
      reinterpret_cast<const ParameterCompressReader*>(
          request->parameter_value().data());
  int size             = reader->item_size();
  uint64_t total_bytes = 0;

  for (int i = 0; i < size; i++) {
    cache_ps_->PutSingleParameter(reader->item(i), 0);
    total_bytes += reader->item(i)->dim * sizeof(float);
  }

  total_put_requests_++;
  total_put_keys_ += size;
  total_put_bytes_ += total_bytes;
}

void BRPCParameterServiceImpl::UpdateParameter(
    google::protobuf::RpcController* controller,
    const UpdateParameterRequest* request,
    UpdateParameterResponse* reply,
    google::protobuf::Closure* done) {
  brpc::ClosureGuard done_guard(done);
}

void BRPCParameterServiceImpl::InitEmbeddingTable(
    google::protobuf::RpcController* controller,
    const InitEmbeddingTableRequest* request,
    InitEmbeddingTableResponse* reply,
    google::protobuf::Closure* done) {
  brpc::ClosureGuard done_guard(done);
}

class BRPCParameterServer : public BaseParameterServer {
public:
  BRPCParameterServer() = default;

  void Run() {
    // 检查是否配置了多分片
    int num_shards = 1; // 默认单分片
    if (config_["cache_ps"].contains("num_shards")) {
      num_shards = config_["cache_ps"]["num_shards"];
    }

    if (num_shards > 1) {
      // 多服务器启动逻辑
      std::cout << "启动分布式参数服务器 (bRPC)，分片数量: " << num_shards
                << std::endl;

      if (!config_["cache_ps"].contains("servers")) {
        LOG(FATAL) << "配置了 num_shards > 1 但缺少 servers 配置";
        return;
      }

      auto servers = config_["cache_ps"]["servers"];
      if (servers.size() != num_shards) {
        LOG(FATAL) << "servers 配置数量 (" << servers.size()
                   << ") 与 num_shards (" << num_shards << ") 不匹配";
        return;
      }

      std::vector<std::thread> server_threads;

      for (auto& server_config : servers) {
        server_threads.emplace_back([this, server_config]() {
          std::string host = server_config["host"];
          int port         = server_config["port"];
          int shard        = server_config["shard"];

          std::string server_address = host + ":" + std::to_string(port);
          auto cache_ps = std::make_unique<CachePS>(config_["cache_ps"]);
          auto service =
              std::make_unique<BRPCParameterServiceImpl>(cache_ps.get());

          brpc::Server server;
          brpc::ServerOptions options;
          options.num_threads = FLAGS_brpc_server_num_threads;

          if (server.AddService(
                  service.get(), brpc::SERVER_DOESNT_OWN_SERVICE) != 0) {
            LOG(ERROR) << "Failed to add service!";
            return;
          }

          if (server.Start(server_address.c_str(), &options) != 0) {
            LOG(ERROR) << "Failed to start bRPC server at " << server_address;
            return;
          }

          std::cout << "bRPC Server shard " << shard << " listening on "
                    << server_address << std::endl;
          server.RunUntilAskedToQuit();
        });
      }

      // 等待所有服务器线程
      for (auto& t : server_threads) {
        t.join();
      }
    } else {
      // 单服务器启动逻辑
      std::cout << "启动单参数服务器 (bRPC)" << std::endl;
      std::string server_address =
          "0.0.0.0:" + std::to_string(FLAGS_brpc_server_port);
      auto cache_ps = std::make_unique<CachePS>(config_["cache_ps"]);
      auto service = std::make_unique<BRPCParameterServiceImpl>(cache_ps.get());

      std::atomic<bool> metrics_running{true};
      std::thread metrics_thread([&service, &metrics_running]() {
        while (metrics_running) {
          std::this_thread::sleep_for(std::chrono::seconds(10));
          service->PrintMetrics();
          service->ResetMetrics();
        }
      });

      brpc::Server server;
      brpc::ServerOptions options;
      options.num_threads = FLAGS_brpc_server_num_threads;

      if (server.AddService(service.get(), brpc::SERVER_DOESNT_OWN_SERVICE) !=
          0) {
        LOG(ERROR) << "Failed to add service!";
        metrics_running = false;
        if (metrics_thread.joinable()) {
          metrics_thread.join();
        }
        return;
      }

      if (server.Start(server_address.c_str(), &options) != 0) {
        LOG(ERROR) << "Failed to start bRPC server at " << server_address;
        metrics_running = false;
        if (metrics_thread.joinable()) {
          metrics_thread.join();
        }
        return;
      }

      std::cout << "bRPC Server listening on " << server_address << std::endl;
      server.RunUntilAskedToQuit();

      metrics_running = false;
      if (metrics_thread.joinable()) {
        metrics_thread.join();
      }
    }
  }
};

FACTORY_REGISTER(BaseParameterServer, BRPCParameterServer, BRPCParameterServer);

} // namespace recstore

int main(int argc, char** argv) {
  gflags::ParseCommandLineFlags(&argc, &argv, true);
  xmh::Reporter::StartReportThread(2000);

  std::ifstream config_file(FLAGS_brpc_config_path);
  nlohmann::json ex;
  config_file >> ex;

  recstore::BRPCParameterServer ps;
  std::cout << "bRPC Parameter server config: " << ex.dump(2) << std::endl;
  ps.Init(ex);
  ps.Run();

  return 0;
}
